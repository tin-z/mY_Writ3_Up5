## CVE-2019-1283 
> Jan 11 2020, Altin Thartori, github.com/tin-z

Before starting, I want to say that the CVE is NOT MINE, in fact, in this write-up I will show you how I replicated the environment to find again the CVE, but mostly, the things I learned by doing it.


###  The Little Bitmap That Could(n’t) 
So all it started with the following [blog](https://www.zerodayinitiative.com/blog/2019/10/31/the-little-bitmap-that-couldnt)  post.
The author describes how he was able to find a security vulnerability by using winafl, and how it ends up Microsoft said that both bugs didn’t meet the bar for servicing and so his report were closed.

The author, not explicitly, describes how to reproduce the environment to start fuzzing with winafl, and so i did.

We need to download and compile/configure, or use the precompiled version, of:
  - [DynamoRIO](https://github.com/DynamoRIO/dynamorio)
  - [winafl](https://github.com/googleprojectzero/winafl)

Then, the command to launch should look like this:
```
afl-fuzz.exe -i c:\temp\path_input -o c:\temp\path_output -D c:\winafl-master\DynamoRIO-Windows-7.1.0-1\bin32\ -t 20000 -- -coverage_module oleaut32.dll -target_module ConsoleApplication1.exe -target_method wmain -nargs 2 -- C:\winafl-master\ConsoleApplication1.exe @@
```

```
Parameter         Description
 -i                Location of seed files
 -o                Location of output files
 -D                Path to DynamoRio
 -t                Time in milliseconds (maximum time before killing a process that is pending)
 -coverage_module  Module to record coverage for
 -target_module    The harness we’ve created
 -target_method    Method inside target module we’re targeting
 -nargs            Number of arguments
 --                Executable with @@ to represent params
```

Now we need to understand the theory that is behind these tools, then we can start to change things, of course we can already stop here, but in that case we are also using a tool, and that can be boring.


### DynamoRIO
In brief, DynamoRIO is a big library, not a framework, that permits us to instrument a binary at runtime, in other words, as the repository says, 
DynamoRIO is a runtime code manipulation system that supports code transformations on any part of a program, while it execute.

We can extend it, in fact, it exports an interface for building dynamic tools for a wide variety of uses, in our case, we are interested in:
  - The instruction counting tool [inscount](https://github.com/DynamoRIO/dynamorio/blob/master/api/samples/inscount.cpp)

We can learn more about it, just by reading this [slide](https://github.com/DynamoRIO/dynamorio/releases/download/release_7_0_0_rc1/DynamoRIO-tutorial-feb2017.pdf), that describes either the use cases and the DynamoRIO System Overview, this last part is realy interesting, all the basic block cache, trace building, etcetera, (probabily it's time that I should buy the [Dragon Book](https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811)).


Then we can start to collects code coverage information:
  ```
    drrun -t drcov -- <app>
  ```


### LightHouse
I found either an amazing plugin for Ida Pro, [lighthouse](https://github.com/gaasedelen/lighthouse), that permits us to visualize the Control flow executed (CFE) by extracting the code coverage previously collected with DynamRIO.


### WinAfl
 [winafl](https://github.com/googleprojectzero/winafl) is a fork of AFL for fuzzing Windows binaries.

All we need to know, for now, is that, instead of instrumenting the code at compilation time, WinAFL supports the following instrumentation modes:

    - Dynamic instrumentation using DynamoRIO (http://dynamorio.org/)
    - Hardware tracing using Intel PT
    - Static instrumentation via Syzygy


### AFL
Before going further we need to learn more about [AFL](https://github.com/google/AFL), I already meet that requirement, (oh lucky me), but in case you haven't just read these docs:

  - [QuickStartGuide.txt](https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt) -suggested
  - [historical-notes.txt](https://github.com/google/AFL/blob/master/docs/historical_notes.txt)
  - [technical-details.txt](https://github.com/google/AFL/blob/master/docs/technical_details.txt)
  - [life-pro-tips.txt](https://github.com/google/AFL/blob/master/docs/life_pro_tips.txt) -optional
  - [notes-for-asan.txt](https://github.com/google/AFL/blob/master/docs/notes_for_asan.txt) -optional


### Ready

Now we can start it by using winafl.

In my case I did fuzzing the function 'OleLoadPicturePath', more [here](https://docs.microsoft.com/en-us/windows/win32/api/olectl/nf-olectl-oleloadpicturepath), that it is in ole32.dll.

This is the entry-point I did [ConsoleApplication1.cpp](./ConsoleApplication1.cpp), then I compiled it with Visual Studio 2017 CE.

By first I didn't find nothing, so then I realized that I must give it better input, and I downloaded these [samples](https://www.fileformat.info/format/bmp/sample/index.htm) and selecting also the files with less then 1MB.

After less then an hour I have got some crashes, (oh lucky me, no this time I'm not hironic), now we must report it to Microsoft, we can look these [FAQs](https://www.microsoft.com/en-us/msrc/faqs-report-an-issue).

Before report it to Microsoft, we must understand a little more about the crash, in my case i have a [OOB Read](https://cwe.mitre.org/data/definitions/125.html), and so this is what we can do:
  1. minimize the test-case by using afl-tmin ([minimized](./minimized))
  2. memory dump, dynamic analysis ([minidump](./minidump.zip), [bugidOutput](./bugidOutput.zip))
  3. reverse engineering the crash,code,library (lot of codes not documented here)
  4. POC


Here we can find some AFL/WinAFL Tips and Tricks [here](https://blog.fadyothman.com/afl-tips-tricks/).

We can get a memory dump by using windbg: ``` > .dump /mfh minidump.dmp ```

We can get more info about a crash by using [BugId](https://github.com/SkyLined/BugId)


In the end, my report has been addressed with CVE-2019-1283, and so the case closed as duplicate case.
